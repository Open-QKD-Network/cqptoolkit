Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 chromium-browser (68.0.3440.106-0ubuntu0.18.04.1) bionic; urgency=medium
 .
   * Upstream release: 68.0.3440.106
Author: Olivier Tilloy <olivier.tilloy@canonical.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2018-09-06

--- chromium-browser-68.0.3440.106.orig/net/BUILD.gn
+++ chromium-browser-68.0.3440.106/net/BUILD.gn
@@ -73,6 +73,10 @@ config("net_internal_config") {
     }
   }
 
+  if (use_psk) {
+    defines += [ "USE_PSK" ]
+  }
+
   if (enable_built_in_dns) {
     defines += [ "ENABLE_BUILT_IN_DNS" ]
   }
@@ -375,6 +379,10 @@ component("net") {
     deps += [ "//net/http:generate_transport_security_state" ]
   }
 
+  if (use_psk) {
+    deps += [ "//third_party/cqp:cqptoolkit" ]
+  }
+
   public_deps = [
     ":net_nqe_proto",
     ":net_quic_proto",
@@ -2058,6 +2066,7 @@ component("net") {
 
   cflags = []
   configs += net_configs
+  cflags += [ "-stdlib=libstdc++" ]
 
   public_deps += [
     ":buildflags",
@@ -5553,6 +5562,10 @@ test("net_unittests") {
     }
   }
 
+  if (use_psk) {
+    defines += [ "USE_PSK" ]
+  }
+
   if (use_kerberos) {
     defines += [ "USE_KERBEROS" ]
   }
--- chromium-browser-68.0.3440.106.orig/net/features.gni
+++ chromium-browser-68.0.3440.106/net/features.gni
@@ -39,6 +39,9 @@ declare_args() {
   # willing to take the responsibility to make sure that all important
   # connections use HTTPS.
   include_transport_security_state_preload_list = true
+
+  # allow pre-shared keys
+  use_psk = false
 }
 
 declare_args() {
--- chromium-browser-68.0.3440.106.orig/net/socket/ssl_client_socket_impl.cc
+++ chromium-browser-68.0.3440.106/net/socket/ssl_client_socket_impl.cc
@@ -61,6 +61,11 @@
 #include "third_party/boringssl/src/include/openssl/mem.h"
 #include "third_party/boringssl/src/include/openssl/ssl.h"
 
+#if defined(USE_PSK)
+#include "CQPToolkit/Util/ConsoleLogger.h"
+#include "CQPToolkit/Util/Util.h"
+#endif
+
 #if !defined(OS_NACL)
 #include "net/ssl/ssl_key_logger.h"
 #endif
@@ -323,6 +327,9 @@ class SSLClientSocketImpl::SSLContext {
     SSL_CTX_set0_buffer_pool(ssl_ctx_.get(), x509_util::GetBufferPool());
 
     SSL_CTX_set_msg_callback(ssl_ctx_.get(), MessageCallback);
+    #if defined(USE_PSK)
+    SSL_CTX_set_psk_client_callback(ssl_ctx_.get(), PSKClientCallback);
+    #endif
   }
 
   static int ClientCertRequestCallback(SSL* ssl, void* arg) {
@@ -378,6 +385,16 @@ class SSLClientSocketImpl::SSLContext {
     return socket->MessageCallback(is_write, content_type, buf, len);
   }
 
+#if defined(USE_PSK)
+  static unsigned int PSKClientCallback(SSL* ssl,
+                                const char *hint,
+                                char *identity, unsigned int max_identity_len,
+                                unsigned char *psk, unsigned int max_psk_len) {
+    SSLClientSocketImpl* socket = GetInstance()->GetClientSocketFromSSL(ssl);
+    return socket->PSKClientCallback(ssl, hint, identity, max_identity_len, psk, max_psk_len);
+  }
+#endif
+
   // This is the index used with SSL_get_ex_data to retrieve the owner
   // SSLClientSocketImpl object from an SSL instance.
   int ssl_socket_data_index_;
@@ -887,7 +904,11 @@ int SSLClientSocketImpl::Init() {
 
   // Use BoringSSL defaults, but disable HMAC-SHA1 ciphers in ECDSA. These are
   // the remaining CBC-mode ECDSA ciphers.
+#if defined(USE_PSK)
+  std::string command("ALL::!ECDSA+SHA1:!kRSA+AESGCM");
+#else
   std::string command("ALL::!aPSK:!ECDSA+SHA1");
+#endif
 
   if (ssl_config_.require_ecdhe)
     command.append(":!kRSA");
@@ -1743,6 +1764,68 @@ void SSLClientSocketImpl::MessageCallbac
   }
 }
 
+#if defined(USE_PSK)
+unsigned int SSLClientSocketImpl::PSKClientCallback(SSL* ssl,
+                                const char *hint,
+                                char *identity, unsigned int max_identity_len,
+                                unsigned char *psk, unsigned int max_psk_len)
+{
+  unsigned int result = 0;
+  using namespace cqp;
+  using namespace cqp::keygen;
+  ConsoleLogger::Enable();
+  DefaultLogger().SetOutputLevel(LogLevel::Trace);
+
+  for(auto& token : HSMStore::FindTokens({"libsofthsm2.so"}))
+  {
+      std::unique_ptr<HSMStore> store {new HSMStore(token, this)};
+
+      uint64_t keyId = 0;
+      std::string destination;
+
+      PSK keyValue;
+      LOGTRACE("Looking for key for " + hint);
+      if(store->FindKey(hint, keyId, keyValue) && keyValue.size() <= max_psk_len)
+      {
+          std::copy(keyValue.begin(), keyValue.end(), psk);
+          std::string keyIdString = cqp::ToHexString(keyId);
+          strncpy(identity, keyIdString.c_str(), max_identity_len);
+          result = keyValue.size();
+      } // if key found
+
+  } // for tokens
+
+  return result;
+}
+
+bool SSLClientSocketImpl::GetHSMPin(const std::string& tokenSerial, const std::string& tokenLabel,
+                                 cqp::keygen::UserType& login, std::string& pin)
+{
+  // TODO
+  /*bool result = false;
+  crypto::CryptoModuleBlockingPasswordDelegate* delegate =
+    CreateCryptoModuleBlockingPasswordDelegate(CryptoModulePasswordReason::kCryptoModulePasswordClientAuth, HostPortPair("todo", 443));
+
+  if (delegate) {
+    bool cancelled = false;
+    pin = delegate->RequestPassword(tokenLabel, false, &cancelled);
+    if (!cancelled)
+    {
+      result = true;
+    }
+    
+  } else {
+    DLOG(ERROR) << "PK11 password requested with nullptr arg";
+  }
+
+  return result;
+  */
+  pin = "1234";
+  return true;
+}
+
+#endif
+
 void SSLClientSocketImpl::LogConnectEndEvent(int rv) {
   if (rv != OK) {
     net_log_.EndEventWithNetErrorCode(NetLogEventType::SSL_CONNECT, rv);
--- chromium-browser-68.0.3440.106.orig/net/socket/ssl_client_socket_impl.h
+++ chromium-browser-68.0.3440.106/net/socket/ssl_client_socket_impl.h
@@ -36,6 +36,10 @@
 #include "third_party/boringssl/src/include/openssl/base.h"
 #include "third_party/boringssl/src/include/openssl/ssl.h"
 
+#if defined(USE_PSK)
+#include "CQPToolkit/KeyGen/HSMStore.h"
+#endif
+
 namespace base {
 class FilePath;
 namespace trace_event {
@@ -59,7 +63,11 @@ using TokenBindingSignatureMap =
                    std::vector<uint8_t>>;
 
 class SSLClientSocketImpl : public SSLClientSocket,
-                            public SocketBIOAdapter::Delegate {
+                            public SocketBIOAdapter::Delegate
+#if defined(USE_PSK)
+                            , public cqp::keygen::IPinCallback
+#endif
+                            {
  public:
   // Takes ownership of the transport_socket, which may already be connected.
   // The given hostname will be compared with the name(s) in the server's
@@ -216,6 +224,16 @@ class SSLClientSocketImpl : public SSLCl
                        int content_type,
                        const void* buf,
                        size_t len);
+#if defined(USE_PSK)
+  // called when a key is needed
+  unsigned int PSKClientCallback(SSL* ssl,
+                                const char *hint,
+                                char *identity, unsigned int max_identity_len,
+                                unsigned char *psk, unsigned int max_psk_len);
+
+  bool GetHSMPin(const std::string& tokenSerial, const std::string& tokenLabel,
+                                   cqp::keygen::UserType& login, std::string& pin) override;
+#endif
 
   int TokenBindingAdd(const uint8_t** out,
                       size_t* out_len,
--- chromium-browser-68.0.3440.106.orig/services/network/public/cpp/cors/cors_legacy.h
+++ chromium-browser-68.0.3440.106/services/network/public/cpp/cors/cors_legacy.h
@@ -6,6 +6,7 @@
 #define SERVICES_NETWORK_PUBLIC_CPP_CORS_CORS_LEGACY_H_
 
 #include <vector>
+#include <string>
 
 #include "base/component_export.h"
 
--- /dev/null
+++ chromium-browser-68.0.3440.106/third_party/cqp/BUILD.gn
@@ -0,0 +1,11 @@
+
+config("cqptoolkit_config")
+{
+    #include_dirs = [ "/home/rc15345/code/CQPToolkit/src/", "/home/rc15345/code/CQPToolkit/build/gcc/src/" ]
+    #lib_dirs = [ "/home/rc15345/code/CQPToolkit/build/gcc/src/CQPToolkit" ]
+    libs = [ "CQPToolkit-x86_64", "curl" ]
+}
+
+static_library("cqptoolkit") {
+    public_configs = [ ":cqptoolkit_config" ]
+}
