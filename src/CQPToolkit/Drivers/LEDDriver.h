/*!
* @file
* @brief CQP Toolkit - LED Driver board
*
* @copyright Copyright (C) University of Bristol 2016
*    This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. 
*    If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
*    See LICENSE file for details.
* @date 29 Feb 2016
* @author Richard Collins <richard.collins@bristol.ac.uk>
*/
#pragma once
#include "CQPToolkit/cqptoolkit_export.h"
#include "CQPToolkit/Interfaces/IPhotonGenerator.h"
#include "CQPToolkit/Drivers/Serial.h"
#include "CQPToolkit/Statistics/Frames.h"
#include "Algorithms/Util/Provider.h"
#include "Algorithms/Util/Strings.h"

namespace cqp
{
    namespace config {
        class DeviceConfig;
    }
    class Usb;
    class IRandom;
    class IEmitterEventCallback;

    /// Driver for Daves LED driver board
    class CQPTOOLKIT_EXPORT LEDDriver :
            public virtual IPhotonGenerator,
            public Provider<IEmitterEventCallback>
    {
    public:
        /**
         * @brief LEDDriver
         * Create the driver with strings
         * @param randomSource randomness
         * @param controlName The path to the serial device
         * @param usbSerialNumber the serial number of the usb device, use empty to pick the first one
         */
        LEDDriver(IRandom* randomSource, const std::string& controlName = "", const std::string& usbSerialNumber = "");

        /**
         * @brief LEDDriver
         * Create the driver with existing devices
         * @param randomSource randomness
         * @param controlDev The serial control device
         * @param dataDev The bulk transfer usb device
         */
        LEDDriver(IRandom* randomSource, std::unique_ptr<Serial> controlDev, std::unique_ptr<Usb> dataDev);

        /// destructor
        virtual ~LEDDriver() override = default;

        /// @name IPhotonGenerator Interface realisation
        ///@{

        /// @copydoc IPhotonGenerator::Fire
        bool Fire() override
        {
            return Fire(photonsPerBurst);
        }

        /// @copydoc IPhotonGenerator::StartFrame
        void StartFrame() override;
        /// @copydoc IPhotonGenerator::EndFrame
        void EndFrame() override;

        /// @copydoc IPhotonGenerator::Fire
        /// @param numQubits How many qubits to send in one burst
        bool Fire(unsigned long numQubits);

        ///@}

        /**
         * @brief GetAddress
         * @return The address of the device
         */
        URI GetAddress() const;

        /// Statistics generated by this device
        stats::Frames myStats;

        /// definition of URL parameters used in the device address
        struct Parameters
        {
            /// the name of the serial device
            static NAMEDSTRING(serial);
            /// The serial number of the usb device
            static NAMEDSTRING(usbserial);
        };

        /**
         * @brief Initialise the device
         * @return true on success
         */
        bool Initialise(config::DeviceConfig& parameters);

        void SetPhotonsPerBurst(uint64_t numPhotons) {
            photonsPerBurst = numPhotons;
        }
    protected: // members
        // Instruct the compiler that we do not want any extra bytes to be added inbetween values in the structures
        // Care should be taken to ensure that each structure meets the alignment requirements of the target system.
#pragma pack(push, 1)

        /// The command being issued or replied to.
        enum class Command : uint8_t
        {
            Invalid     = 0x00,
            Test        = 0x08,
            Data        = 0x07
        };

        /// Data associated with the Test command
        struct Test
        {
        public:
            /// The kind of test pattern
            enum class Action : uint8_t
            {
                All_Ones        = 0x11,
                All_Twos        = 0x12,
                All_Threes      = 0x13,
                All_Fours       = 0x14,
                Increment       = 0x17,
                Decrement       = 0x18,
                Stop            = 0x1F
            };
            /// The kind of test pattern
            Action action;
        };

        /// Data associated with the Data command.
        struct Data
        {
        public:
            /// First element in the array of data
            Qubit    bits;
        };

        /// Data common to all packets sent to/received from the device
        struct Header
        {
        public:
            /// The command to be performed
            /// This will effect the length of the message
            Command     cmd;
            /// The crc of the entire message
            /// @todo Does this include the header or not.
            uint8_t     crc;
            /// The length of the entire message
            uint32_t    msgLength;
        };

        /// Definition of all possible structures which could appear after the header.
        /// The valid element of this union is defined by the cmd value in the header.
        union Payload
        {
            /// ?
            Test    test;
            /// Data associated with the Data command.
            Data    data;
        };

        /// The definition of a complete message in including header.
        struct Message
        {
            /// preamble for message
            Header      header;
            /// specific message data
            Payload     payload;
        };
        /// Exit the pack mode and return the packing to it's previous value.
#pragma pack(pop)

        std::unique_ptr<Usb> dataPort;
        /// The serial port used to configure the device
        std::unique_ptr<Serial> configPort;
        /// speed used to communicate with the device
        Serial::BaudRate myBaudRate = Serial::BaudRate::B_9600;
        /// the usb vendor id of the device
        const uint16_t usbVID = 0x221a;
        /// the usb product id of the device
        const uint16_t usbPID = 0x100;
        /// usb end point to use
        const unsigned char UsbEndpoint = 0x02;

        /// how many bits are transmitted for each qubit
        const uint8_t bitsPerQubit = 2;
        /// Stuff to send over serial to get Alice to send at 10MHz with a reasonable pulse width (7ns?)
        const char divEndpoint = 0x46;
        /// configuration command
        const char div10Mhz = 19;
        /// end marker for configuration command
        const char commandEnd = '$';
        /// ?
        const char delEndPoint = 0x50;
        /// ?
        const char del7ns = 28;
        /// Source for random qubits
        IRandom* randomness = nullptr;
        /// number of photons to send each frame
        unsigned long photonsPerBurst = 1024;

        /// The point at which the frame was started
        std::chrono::high_resolution_clock::time_point epoc;
        /// current frame number
        SequenceNumber frame = 1;

    };
}
