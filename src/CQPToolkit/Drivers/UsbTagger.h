/*!
 * @file
 * @brief CQP Toolkit - Usb Tagger
 *
 * @copyright Copyright (C) University of Bristol 2016
 *    This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. 
*    If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
*    See LICENSE file for details.
 * @date 08 Feb 2016
 * @author Richard Collins <richard.collins@bristol.ac.uk>
 */
#pragma once
#include "QKDInterfaces/IDetector.grpc.pb.h"
#include "CQPToolkit/Drivers/Serial.h"
#include "Algorithms/Util/Provider.h"
#include "CQPToolkit/Interfaces/IDetectionEventPublisher.h"
#include "Algorithms/Util/Strings.h"
#include "CQPToolkit/Statistics/Frames.h"

struct libusb_transfer;

namespace cqp
{
    namespace remote {
        class DeviceConfig;
    }
    class Usb;

    /// Class for controlling the "RWN 11" time tagger and coincidence counter built at UOB.
    class CQPTOOLKIT_EXPORT UsbTagger :
            public remote::IDetector::Service,
            public Provider<IDetectionEventCallback>
    {
    public:
        /**
         * @brief UsbTagger
         * Create the tagger using device names
         * @param controlName The path of the serial device
         * @param usbSerialNumber The serial number of the usb device or empty for the first device
         */
        UsbTagger(const std::string& controlName = "", const std::string& usbSerialNumber = "");

        /**
         * @brief UsbTagger
         * Create the tagger using initialised devices
         * @param controlDev The serial device
         * @param dataDev The usb device
         */
        UsbTagger(std::unique_ptr<Serial> controlDev, std::unique_ptr<Usb> dataDev);

        /// Destructor
        virtual ~UsbTagger() override;

        ///@{
        /// @name remote::IDetector interface

        /// @copydoc remote::IDetector::StartDetecting
        grpc::Status StartDetecting(grpc::ServerContext*, const google::protobuf::Timestamp* request, google::protobuf::Empty*) override;
        /// @copydoc remote::IDetector::StopDetecting
        grpc::Status StopDetecting(grpc::ServerContext*, const google::protobuf::Timestamp* request, google::protobuf::Empty*) override;
        ///@}

        /**
         * @brief Initialise the device
         * @return true on success
         */
        bool Initialise();

        /**
         * @brief GetAddress
         * @return The address of the device
         */
        URI GetAddress();

        /// Statistics generated by this device
        stats::Frames myStats;

        /// definition of URL parameters used in the device address
        struct Parameters
        {
            /// the name of the serial device
            static CONSTSTRING serial = "serial";
            /// The serial number of the usb device
            static CONSTSTRING usbserial = "usbserial";
        };

        /**
         * @brief SetChannelMappings
         * Specify how detector numbers are mapped to qubits
         * @param mapping
         */
        void SetChannelMappings(const std::vector<Qubit>& mapping);

    protected: // members
        /// Impl class for managing the incomming data
        class DataPusher;

        /// Device used for the C&C of the device
        std::unique_ptr<Serial> configPort;
        /// Transfers the results using bulk transfer
        std::unique_ptr<Usb> dataPort;
        /// pulls data from the device and proceses it
        std::unique_ptr<DataPusher> dataPusher;

        /// The vendor id of this device
        static constexpr uint16_t usbVID = 0x221A;
        /// The product id of the device
        static constexpr uint16_t usbPID = 0x0100;
        /// the request id for the standard bulk transfer read
        static constexpr uint8_t bulkReadRequest = 0x82;
        /// speed used to communicate with the device
        Serial::BaudRate myBaudRate = Serial::BaudRate::B_9600;
        /// how the detector channels are linked to qubits
        std::vector<Qubit> channelMappings {0, 1, 2, 3};
        /// The maximum number of bytes to read in any one bulk read event
        static const int maxBulkRead = 8192;
    };

}
